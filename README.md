Жадібний алгоритм:

- Часова складність: O(n), де n - кількість різних номіналів монет.
- Пам'ять: О(1), оскільки жадібний алгоритм просто проходить по масиву монет і формує результат.

Алгоритм динамічного програмування:

- Часова складність: O(amount \* n), де amount - сума, для якої потрібно знайти решту, а n - кількість різних номіналів монет. Це через те, що ми заповнюємо таблицю dp розміром amount \* n.
- Пам'ять: O(amount), оскільки ми використовуємо таблицю dp розміром amount для зберігання інформації про мінімальну кількість монет для кожної суми.

Ось які висновки можна зробити з цього порівняння:

- Жадібний алгоритм має меншу часову складність, тому для невеликих сум він може бути ефективнішим.
- Однак при збільшенні суми алгоритм динамічного програмування стає більш ефективним через оптимізацію кількості монет.
- Якщо кількість різних номіналів монет невелика, то жадібний алгоритм може бути оптимальним, оскільки він не потребує додаткової пам'яті для обробки.
- У випадку, коли кількість різних номіналів монет велика і/або сума значимо велика, алгоритм динамічного програмування буде більш ефективним і оптимальним з точки зору швидкості та кількості монет, використаних для видачі решти.
